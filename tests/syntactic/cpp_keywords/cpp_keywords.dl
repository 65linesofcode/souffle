// Souffle - A Datalog Compiler
// Copyright (c) 2016, The Souffle Developers. All rights reserved
// Licensed under the Universal Permissive License v 1.0 as shown at:
// - https://opensource.org/licenses/UPL
// - <souffle root>/licenses/SOUFFLE-UPL.txt

.type number_record = [ x:number ]
.decl alignas(x:number_record)
alignas([1]).
.decl alignof(x:number_record)
alignof([1]).
.decl asm(x:number_record)
asm([1]).
.decl atomic_cancel(x:number_record)
atomic_cancel([1]).
.decl atomic_commit(x:number_record)
atomic_commit([1]).
.decl atomic_noexcept(x:number_record)
atomic_noexcept([1]).
.decl auto(x:number_record)
auto([1]).
.decl bool(x:number_record)
bool([1]).
.decl break(x:number_record)
break([1]).
.decl case(x:number_record)
case([1]).
.decl catch(x:number_record)
catch([1]).
.decl char(x:number_record)
char([1]).
.decl char16_t(x:number_record)
char16_t([1]).
.decl char32_t(x:number_record)
char32_t([1]).
.decl class(x:number_record)
class([1]).
.decl concept(x:number_record)
concept([1]).
.decl const(x:number_record)
const([1]).
.decl constexpr(x:number_record)
constexpr([1]).
.decl const_cast(x:number_record)
const_cast([1]).
.decl continue(x:number_record)
continue([1]).
.decl decltype(x:number_record)
decltype([1]).
.decl default(x:number_record)
default([1]).
.decl delete(x:number_record)
delete([1]).
.decl do(x:number_record)
do([1]).
.decl double(x:number_record)
double([1]).
.decl dynamic_cast(x:number_record)
dynamic_cast([1]).
.decl enum(x:number_record)
enum([1]).
.decl explicit(x:number_record)
explicit([1]).
.decl export(x:number_record)
export([1]).
.decl extern(x:number_record)
extern([1]).
.decl false(x:number_record)
false([1]).
.decl float(x:number_record)
float([1]).
.decl for(x:number_record)
for([1]).
.decl friend(x:number_record)
friend([1]).
.decl goto(x:number_record)
goto([1]).
.decl inline(x:number_record)
inline([1]).
.decl int(x:number_record)
int([1]).
.decl import(x:number_record)
import([1]).
.decl long(x:number_record)
long([1]).
.decl module(x:number_record)
module([1]).
.decl mutable(x:number_record)
mutable([1]).
.decl namespace(x:number_record)
namespace([1]).
.decl new(x:number_record)
new([1]).
.decl noexcept(x:number_record)
noexcept([1]).
.decl nullptr(x:number_record)
nullptr([1]).
.decl operator(x:number_record)
operator([1]).
.decl or(x:number_record)
or([1]).
.decl private(x:number_record)
private([1]).
.decl protected(x:number_record)
protected([1]).
.decl public(x:number_record)
public([1]).
.decl register(x:number_record)
register([1]).
.decl reinterpret_cast(x:number_record)
reinterpret_cast([1]).
.decl requires(x:number_record)
requires([1]).
.decl return(x:number_record)
return([1]).
.decl short(x:number_record)
short([1]).
.decl signed(x:number_record)
signed([1]).
.decl sizeof(x:number_record)
sizeof([1]).
.decl static(x:number_record)
static([1]).
.decl static_assert(x:number_record)
static_assert([1]).
.decl static_cast(x:number_record)
static_cast([1]).
.decl struct(x:number_record)
struct([1]).
.decl switch(x:number_record)
switch([1]).
.decl synchronized(x:number_record)
synchronized([1]).
.decl template(x:number_record)
template([1]).
.decl this(x:number_record)
this([1]).
.decl thread_local(x:number_record)
thread_local([1]).
.decl throw(x:number_record)
throw([1]).
.decl true(x:number_record)
true([1]).
.decl try(x:number_record)
try([1]).
.decl typedef(x:number_record)
typedef([1]).
.decl typeid(x:number_record)
typeid([1]).
.decl typename(x:number_record)
typename([1]).
.decl union(x:number_record)
union([1]).
.decl unsigned(x:number_record)
unsigned([1]).
.decl using(x:number_record)
using([1]).
.decl virtual(x:number_record)
virtual([1]).
.decl void(x:number_record)
void([1]).
.decl volatile(x:number_record)
volatile([1]).
.decl wchar_t(x:number_record)
wchar_t([1]).
.decl while(x:number_record)
while([1]).
.decl xor(x:number_record)
xor([1]).
.decl compl(x:number_record)
compl([1]).
.decl bitor(x:number_record)
bitor([1]).
.decl bitand(x:number_record)
bitand([1]).
.decl and_eq(x:number_record)
and_eq([1]).
.decl or_eq(x:number_record)
or_eq([1]).
.decl xor_eq(x:number_record)
xor_eq([1]).
.decl not(x:number_record)
not([1]).
.decl and(x:number_record)
and([1]).
.decl not_eq(x:number_record)
not_eq([1]).
.decl override(x:number_record)
override([1]).
.decl final(x:number_record)
final([1]).
.decl transaction_safe(x:number_record)
transaction_safe([1]).
.decl transaction_safe_dynamic(x:number_record)
transaction_safe_dynamic([1]).
.decl if(x:number_record)
if([1]).
.decl elif(x:number_record)
elif([1]).
.decl else(x:number_record)
else([1]).
.decl endif(x:number_record)
endif([1]).
.decl defined(x:number_record)
defined([1]).
.decl ifdef(x:number_record)
ifdef([1]).
.decl ifndef(x:number_record)
ifndef([1]).
.decl define(x:number_record)
define([1]).
.decl undef(x:number_record)
undef([1]).
.decl include(x:number_record)
include([1]).
.decl line(x:number_record)
line([1]).
.decl error(x:number_record)
error([1]).
.decl pragma(x:number_record)
pragma([1]).
.decl _Pragma(x:number_record)
_Pragma([1]).
.decl worked?(x:number)
.output worked?()
worked?(X) :- alignas([X]), alignof([X]), asm([X]), atomic_cancel([X]), atomic_commit([X]), atomic_noexcept([X]), auto([X]), bool([X]), break([X]), case([X]), catch([X]), char([X]), char16_t([X]), char32_t([X]), class([X]), concept([X]), const([X]), constexpr([X]), const_cast([X]), continue([X]), decltype([X]), default([X]), delete([X]), do([X]), double([X]), dynamic_cast([X]), enum([X]), explicit([X]), export([X]), extern([X]), false([X]), float([X]), for([X]), friend([X]), goto([X]), inline([X]), int([X]), import([X]), long([X]), module([X]), mutable([X]), namespace([X]), new([X]), noexcept([X]), nullptr([X]), operator([X]), or([X]), private([X]), protected([X]), public([X]), register([X]), reinterpret_cast([X]), requires([X]), return([X]), short([X]), signed([X]), sizeof([X]), static([X]), static_assert([X]), static_cast([X]), struct([X]), switch([X]), synchronized([X]), template([X]), this([X]), thread_local([X]), throw([X]), true([X]), try([X]), typedef([X]), typeid([X]), typename([X]), union([X]), unsigned([X]), using([X]), virtual([X]), void([X]), volatile([X]), wchar_t([X]), while([X]), xor([X]), compl([X]), bitor([X]), bitand([X]), and_eq([X]), or_eq([X]), xor_eq([X]), not([X]), and([X]), not_eq([X]), override([X]), final([X]), transaction_safe([X]), transaction_safe_dynamic([X]), if([X]), elif([X]), else([X]), endif([X]), defined([X]), ifdef([X]), ifndef([X]), define([X]), undef([X]), include([X]), line([X]), error([X]), pragma([X]), _Pragma([X]).

