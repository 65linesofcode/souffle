#include "AstVisitor.h"
#include "Global.h"
#include "IODirectives.h"
#include "MagicSet.h"

namespace souffle {
/* general functions */

void DEBUGprintProgram(std::unique_ptr<AstProgram> program) {
    std::cout << *program << std::endl;
}

// checks whether the adorned version of two predicates is equal
bool isEqualAdornment(
        AstRelationIdentifier pred1, std::string adorn1, AstRelationIdentifier pred2, std::string adorn2) {
    if ((pred1 == pred2) && (adorn1.compare(adorn2) == 0)) {
        return true;
    }
    return false;
}

// checks whether an element is contained within a set
template <class T>
bool contains(std::set<T> set, T element) {
    if (set.find(element) != set.end()) {
        return true;
    }
    return false;
}

// checks whether a given adorned predicate is contained within a set
bool contains(std::set<AdornedPredicate> adornedPredicates, AstRelationIdentifier atomName,
        std::string atomAdornment) {
    for (AdornedPredicate seenPred : adornedPredicates) {
        if (isEqualAdornment(seenPred.getName(), seenPred.getAdornment(), atomName, atomAdornment)) {
            return true;
        }
    }
    return false;
}

// splits up a string into a set given a delimiter
std::set<std::string> split(std::string str, char delimiter) {
    std::set<std::string> res;
    int begin = 0;
    for (size_t i = 0; i < str.size(); i++) {
        if (str[i] == delimiter) {
            std::string token = str.substr(begin, (i - begin));
            res.insert(token);
            begin = i + 1;
        }
    }
    res.insert(str.substr(begin)); // add in the last remaining token
    res.erase(""); // remove empty tokens
    return res;
}

// checks whether a string begins with a given string
bool hasPrefix(std::string str, std::string prefix) {
    if (str.substr(0, prefix.size()).compare(prefix) == 0) {
        return true;
    }
    return false;
}

// checks whether the given relation is generated by an aggregator
// TODO: check if this covers too much (e.g. user-defined __agg_rel_x)
bool isAggRel(AstRelationIdentifier rel) {
    return hasPrefix(rel.getNames()[0], "__agg_rel_");
}

// gets the position of the final underscore in a given string
int getEndpoint(std::string mainName) {
    int endpt = mainName.size() - 1;
    while (endpt >= 0 && mainName[endpt] != '_') {
        endpt--;
    }
    if (endpt == -1) {
        endpt = mainName.size();
    }
    return endpt;
}

/* argument-related functions */

// returns the string representation of a given argument
std::string getString(AstArgument* arg) {
    std::stringstream argStream;
    argStream.str("");
    argStream << *arg;
    return argStream.str();
}

// checks whether a given atom has a bound argument
bool hasBoundArgument(AstAtom* atom, std::set<std::string> boundArgs) {
    for (AstArgument* arg : atom->getArguments()) {
        std::string name = getString(arg);
        if (boundArgs.find(name) != boundArgs.end()) {
            return true;  // found a bound argument, so can stop
        }
    }
    return false;
}

// checks whether the lhs is bound by a binary functor (and is not bound yet)
bool isBoundArg(AstArgument* lhs, AstArgument* rhs, std::set<std::string> boundArgs) {
    std::string lhs_name = getString(lhs);
    std::string rhs_name = getString(rhs);

    // only want to check variables we have not bound yet
    if (dynamic_cast<AstVariable*>(lhs) && (boundArgs.find(lhs_name) == boundArgs.end())) {
        // return true if the rhs is a bound variable or a constant
        if (dynamic_cast<AstVariable*>(rhs) && (boundArgs.find(rhs_name) != boundArgs.end())) {
            return true;
        } else if (dynamic_cast<AstConstant*>(rhs)) {
            return true;
        }
    }
    return false;
}

/* functor/aggregator check functions */

// checks whether an argument involves functors or aggregators
// TODO: name change
bool argumentContainsFunctors(AstArgument* arg) {
    if (dynamic_cast<AstFunctor*>(arg)) {
        // functor found!
        return true;
    } else if (dynamic_cast<AstRecordInit*>(arg)) {
        AstRecordInit* recordarg = dynamic_cast<AstRecordInit*>(arg);
        for (AstArgument* subarg : recordarg->getArguments()) {
            if (argumentContainsFunctors(subarg)) {
                return true;
            }
        }
    } else if (dynamic_cast<AstTypeCast*>(arg)) {
        AstTypeCast* typearg = dynamic_cast<AstTypeCast*>(arg);
        if (argumentContainsFunctors(typearg->getValue())) {
            return true;
        }
    } else if (dynamic_cast<AstAggregator*>(arg)) {
        // aggregator found!
        return true;
    }
    return false;
}

// checks whether an atom involves functors or aggregators
bool atomContainsFunctors(AstAtom* atom) {
    for (AstArgument* arg : atom->getArguments()) {
        if (argumentContainsFunctors(arg)) {
            return true;
        }
    }
    return false;
}

// checks whether a literal involves functors or aggregators
bool literalContainsFunctors(AstLiteral* lit) {
    if (dynamic_cast<AstAtom*>(lit)) {
        if (atomContainsFunctors(dynamic_cast<AstAtom*>(lit))) {
            return true;
        }
    } else if (dynamic_cast<AstNegation*>(lit)) {
        AstNegation* negLit = dynamic_cast<AstNegation*>(lit);
        if (atomContainsFunctors(negLit->getAtom())) {
            return true;
        }
    } else {
        AstConstraint* cons = dynamic_cast<AstConstraint*>(lit);
        if (argumentContainsFunctors(cons->getLHS()) || argumentContainsFunctors(cons->getRHS())) {
            return true;
        }
    }
    return false;
}

// checks whether the clause contains functors or aggregators
bool containsFunctors(AstClause* clause) {
    if (atomContainsFunctors(clause->getHead())) {
        return true;
    }
    for (AstLiteral* lit : clause->getBodyLiterals()) {
        if (literalContainsFunctors(lit)) {
            return true;
        }
    }
    return false;
}

/* program-adding related functions */

// returns the new source location of a newly-created node
AstSrcLocation nextSrcLoc(AstSrcLocation orig) {
    static int pos = 0;
    pos += 1;

    AstSrcLocation newLoc;
    newLoc.filename = orig.filename + "__MAGIC.dl"; // TODO: check if enough
    newLoc.start.line = pos;
    newLoc.end.line = pos;
    newLoc.start.column = 0;
    newLoc.end.column = 1;

    return newLoc;
}

// returns the next available relation name prefixed by "newedb"
std::string getNextEdbName(AstProgram* program) {
    static int edbNum = 0;
    std::stringstream newEdbName;

    // find the next unused relation name of the form "newedbX", X an integer
    do {
        newEdbName.str("");  // check
        edbNum++;
        newEdbName << "newedb" << edbNum;
    } while (program->getRelation(newEdbName.str()) != nullptr);

    return newEdbName.str();
}

// create a new relation with a given name based on a previous relation
AstRelation* createNewRelation(AstRelation* original, AstRelationIdentifier newName) {
    AstRelation* newRelation = new AstRelation();
    newRelation->setSrcLoc(nextSrcLoc(original->getSrcLoc()));
    newRelation->setName(newName);

    // copy over the attributes from the original relation
    for (AstAttribute* attr : original->getAttributes()) {
        newRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
    }

    return newRelation;
}

// returns the magic-set identifier corresponding to a given relation (mX_relation)
AstRelationIdentifier createMagicIdentifier(AstRelationIdentifier relationName, size_t outputNumber) {
    std::vector<std::string> relationNames = relationName.getNames();

    // change the base name to magic-relation format
    std::stringstream newMainName;
    newMainName.str("");
    newMainName << "m" << outputNumber << "_" << relationNames[0];
    AstRelationIdentifier newRelationName(newMainName.str());

    // copy over the other relation names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

// returns the adorned identifier corresponding to a given relation and adornment (relationName_adornment)
AstRelationIdentifier createAdornedIdentifier(AstRelationIdentifier relationName, std::string adornment) {
    std::vector<std::string> relationNames = relationName.getNames();

    // change the base name
    std::stringstream newMainName;
    newMainName.str("");
    newMainName << relationNames[0] << "_" << adornment;  // TODO: check if relationNames[0] always defined
    AstRelationIdentifier newRelationName(newMainName.str());

    // add in the other names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

// returns the requested substring of a given identifier
AstRelationIdentifier createSubIdentifier(AstRelationIdentifier relationName, size_t start, size_t endpt) {
    std::vector<std::string> relationNames = relationName.getNames();

    // get the substring of the base name
    std::stringstream newMainName;
    newMainName.str("");
    newMainName << relationNames[0].substr(start, endpt);  // TODO: check if relationNames[0] always defined
    AstRelationIdentifier newRelationName(newMainName.str());

    // add in the remaining names
    for (size_t i = 1; i < relationNames.size(); i++) {
        newRelationName.append(relationNames[i]);
    }

    return newRelationName;
}

/* functions to find atoms to ignore */

// add all atoms of an argument that contain aggregators to the ignored relations list
// ignoredNames - name of relations already ignored
std::set<AstRelationIdentifier> argumentAddAggregators(
        AstArgument* arg, std::set<AstRelationIdentifier> ignoredNames) {

    std::set<AstRelationIdentifier> retVal = ignoredNames;

    // TODO: check if everything covered
    if (dynamic_cast<AstAggregator*>(arg)) {
        AstAggregator* aggregator = dynamic_cast<AstAggregator*>(arg);
        // aggregator found - add all atoms in body to ignored atoms list
        // TODO: check if correct - is it catching everything?
        for (AstLiteral* lit : aggregator->getBodyLiterals()) {
            if (lit->getAtom() != nullptr) {
                retVal.insert(lit->getAtom()->getName());
            }
        }
    } else if (dynamic_cast<AstFunctor*>(arg)) {
        // if the argument is a functor, check each of its respective
        // arguments for aggregators
        if (dynamic_cast<AstUnaryFunctor*>(arg)) {
            AstUnaryFunctor* func = dynamic_cast<AstUnaryFunctor*>(arg);
            retVal = argumentAddAggregators(func->getOperand(), retVal);
        } else if (dynamic_cast<AstBinaryFunctor*>(arg)) {
            AstBinaryFunctor* func = dynamic_cast<AstBinaryFunctor*>(arg);
            retVal = argumentAddAggregators(func->getLHS(), retVal);
            retVal = argumentAddAggregators(func->getRHS(), retVal);
        } else if (dynamic_cast<AstTernaryFunctor*>(arg)) {
            AstTernaryFunctor* func = dynamic_cast<AstTernaryFunctor*>(arg);
            retVal = argumentAddAggregators(func->getArg(0), retVal);
            retVal = argumentAddAggregators(func->getArg(1), retVal);
            retVal = argumentAddAggregators(func->getArg(2), retVal);
        }
    } else if (dynamic_cast<AstRecordInit*>(arg)) {
        // if the argument is a record, check each of its own arguments for aggregators
        AstRecordInit* rec = dynamic_cast<AstRecordInit*>(arg);
        for (AstArgument* subarg : rec->getArguments()) {
            retVal = argumentAddAggregators(subarg, retVal);
        }
    } else if (dynamic_cast<AstTypeCast*>(arg)) {
        // if the argument is a typecast, check the subargument
        AstTypeCast* tcast = dynamic_cast<AstTypeCast*>(arg);
        retVal = argumentAddAggregators(tcast->getValue(), retVal);
    }

    return retVal;
}

// add all atoms of an atom that contain aggregators to the ignored relations list
std::set<AstRelationIdentifier> atomAddAggregators(
        AstAtom* atom, std::set<AstRelationIdentifier> ignoredNames) {
    std::set<AstRelationIdentifier> retVal = ignoredNames;
    for (AstArgument* arg : atom->getArguments()) {
        retVal = argumentAddAggregators(arg, retVal);
    }
    return retVal;
}

// add all atoms within a clause that contain aggregators to the ignored relations list
std::set<AstRelationIdentifier> addAggregators(
        AstClause* clause, std::set<AstRelationIdentifier> ignoredNames) {
    std::set<AstRelationIdentifier> retVal = ignoredNames;

    // check for aggregators in the head
    retVal = atomAddAggregators(clause->getHead(), retVal);

    // check for aggregators in the body literals
    for (AstLiteral* lit : clause->getBodyLiterals()) {
        if (dynamic_cast<AstAtom*>(lit)) {
            retVal = atomAddAggregators((AstAtom*)lit, retVal);
        } else if (dynamic_cast<AstNegation*>(lit)) {
            retVal = atomAddAggregators((AstAtom*)(lit->getAtom()), retVal);
        } else {
            AstConstraint* cons = dynamic_cast<AstConstraint*>(lit);
            retVal = argumentAddAggregators(cons->getLHS(), retVal);
            retVal = argumentAddAggregators(cons->getRHS(), retVal);
        }
    }
    return retVal;
}

// TODO: 1 - check correctness
// TODO: 2 - there's a much more efficient way to do this...
// TODO: 3 - this is adding the RHS if LHS, make sure the reverse is not assumed ever
// for a given set of relations, add in all the atoms in their rules
std::set<AstRelationIdentifier> addDependencies(
        const AstProgram* program, std::set<AstRelationIdentifier> relations) {
    bool relationsAdded = false;
    std::set<AstRelationIdentifier> retVals;
    for (AstRelationIdentifier relName : relations) {
        retVals.insert(relName); // add the relation itself

        // TODO: change later to use visitor pattern
        for (AstClause* clause : program->getRelation(relName)->getClauses()) {
            for (AstLiteral* lit : clause->getBodyLiterals()) {
                if (dynamic_cast<AstAtom*>(lit) || dynamic_cast<AstNegation*>(lit)) {
                    AstRelationIdentifier addedName = lit->getAtom()->getName();
                    retVals.insert(addedName);
                    if (relations.find(addedName) == relations.end()) {
                        relationsAdded = true;
                    }
                }
            }
        }
    }

    if (relationsAdded) {
        return addDependencies(program, retVals);
    } else {
        return retVals;
    }
}

// ensures that every relation not specified by the magic-transform option
// is ignored by the transformation
std::set<AstRelationIdentifier> addIgnoredRelations(
        const AstProgram* program, std::set<AstRelationIdentifier> relations) {
    // get a set of all relations specified by the option
    std::set<std::string> specifiedRelations = split(Global::config().get("magic-transform"), ',');

    // if a star was used as a relation, then magic set will be performed for all nodes
    if (contains(specifiedRelations, "*")) {
        return relations;
    }

    std::set<AstRelationIdentifier> retVal(relations);
    for (AstRelation* rel : program->getRelations()) {
        // ignore all relations not specified by the option
        std::string mainName = rel->getName().getNames()[0];
        if (!contains(specifiedRelations, mainName)) {
            retVal.insert(rel->getName());
        }
    }

    return retVal;
}

/* =======================  *
 *        Adornment         *
 * =======================  */

// reorders a vector of integers to fit the clause atom-reordering function
std::vector<unsigned int> reorderOrdering(std::vector<unsigned int> order) {
    // when the adornment is computed, the atoms are numbered based on
    // which was chosen by the SIPS first - this is the 'order' vector.
    // want to reorder clause atoms so that the atom labelled 0 is first, and so on.
    // i.e. order[i] denotes where labels[i] should move
    // e.g.: [a, b, c] with label [1, 2, 0] should become [c, a, b]

    // the atom reordering function for clauses, however, moves it as follows:
    // [a, b, c] with label [1, 2, 0] becomes [b, c, a]
    // i.e. labels[i] goes to the position of i in the order vector

    // this function reorders the ordering scheme to match the second type
    std::vector<unsigned int> neworder(order.size());
    for (size_t i = 0; i < order.size(); i++) {
        // this took embarrassingly long to figure out
        neworder[order[i]] = i;
    }
    return neworder;
}

// reorders an adornment based on a given ordering scheme
std::vector<std::string> reorderAdornment(
        std::vector<std::string> adornment, std::vector<unsigned int> order) {
    // order[i] denotes where labels[i] should move
    // [a, b, c] with order [1, 2, 0] -> [c, a, b]
    std::vector<std::string> result(adornment.size());
    for (size_t i = 0; i < adornment.size(); i++) {
        result[order[i]] = adornment[i];
    }
    return result;
}

// computes the adornment of a newly chosen atom
// returns both the adornment and the new list of bound arguments
std::pair<std::string, std::set<std::string>> bindArguments(
        AstAtom* currAtom, std::set<std::string> boundArgs) {
    std::set<std::string> newlyBoundArgs;
    std::string atomAdornment = "";

    for (AstArgument* arg : currAtom->getArguments()) {
        std::string argName = getString(arg);
        if (boundArgs.find(argName) != boundArgs.end()) {
            atomAdornment += "b";  // bound
        } else {
            atomAdornment += "f";            // free
            newlyBoundArgs.insert(argName);  // now bound
        }
    }

    // add newly bound arguments to the list of bound arguments
    for (std::string newArg : newlyBoundArgs) {
        boundArgs.insert(newArg);
    }

    std::pair<std::string, std::set<std::string>> result;
    result.first = atomAdornment;
    result.second = boundArgs;
    return result;
}

// runs the adornment algorithm on an input program
void Adornment::run(const AstTranslationUnit& translationUnit) {
    // Adornment algorithm:

    // Let P be the set of all adorned predicates (initially empty)
    // Let D' be the set of all adorned clauses (initially empty)
    // Let S be the set of all seen predicate adornments

    // Get the program
    // Get the query
    // Adorn the query based on boundness, and add it to P and S
    // While P is not empty
    // -- Pop the first atom out, call it R^c, where c is the adornment
    // -- For every clause Q defining R:
    // -- -- Adorn Q using R^c based on the SIPS chosen 
    // -- -- Add the adorned clause to D'
    // -- -- If the body of the adorned clause contains an
    //        unseen predicate adornment, add it to S and P

    // Output: D' [the set of all adorned clauses]

    const AstProgram* program = translationUnit.getProgram();

    // set up IDB/EDB and the output queries
    std::vector<AstRelationIdentifier> outputQueries;
    std::vector<std::vector<AdornedClause>> adornedProgram;

    for (AstRelation* rel : program->getRelations()) {
        AstRelationIdentifier relName = rel->getName();
        // check if output relation or size is printed
        if (rel->isComputed()) {
            outputQueries.push_back(rel->getName());
            adornmentRelations.push_back(rel->getName());
        }

        // store into edb or idb
        bool is_edb = true;
        for (AstClause* clause : rel->getClauses()) {
            if (!clause->isFact()) {
                is_edb = false;
                break;
            }
        }

        if (is_edb) {
            adornmentEdb.insert(relName);
        } else {
            adornmentIdb.insert(relName);
        }
    }

    // find all negated literals
    std::set<AstRelationIdentifier> negatedLiterals;
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            for (AstLiteral* lit : clause->getBodyLiterals()) {
                if (dynamic_cast<AstNegation*>(lit)) {
                    negatedLiterals.insert(lit->getAtom()->getName());
                }
            }
        }
    }

    negatedLiterals = addDependencies(program, negatedLiterals);
    negatedAtoms = negatedLiterals;

    // find atoms that should be ignored
    for (AstRelation* rel : program->getRelations()) {
        for (AstClause* clause : rel->getClauses()) {
            if (containsFunctors(clause)) {
                ignoredAtoms.insert(clause->getHead()->getName());
            }
            ignoredAtoms = addAggregators(clause, ignoredAtoms);
        }
    }

    for (size_t querynum = 0; querynum < outputQueries.size(); querynum++) {
        AstRelationIdentifier outputQuery = outputQueries[querynum];
        // adornment algorithm
        std::vector<AdornedPredicate> currentPredicates;
        std::set<AdornedPredicate> seenPredicates;
        std::vector<AdornedClause> adornedClauses;

        size_t arity = program->getRelation(outputQuery)->getArity();
        std::string frepeat = std::string(arity, 'f');

        AdornedPredicate outputPredicate(outputQuery, frepeat);
        currentPredicates.push_back(outputPredicate);
        seenPredicates.insert(outputPredicate);

        while (!currentPredicates.empty()) {
            // pop out the first element
            AdornedPredicate currPredicate = currentPredicates[0];
            currentPredicates.erase(currentPredicates.begin());

            // go through all clauses defining it
            AstRelation* rel = program->getRelation(currPredicate.getName());

            for (AstClause* clause : rel->getClauses()) {
                if (clause->isFact()) {
                    continue;
                }

                // TODO: check if it contains it first before doing this
                // if(containsFunctors(clause)){
                //   ignoredAtoms.insert(clause->getHead()->getName());
                // }
                // ignoredAtoms = addAggregators(clause, ignoredAtoms);

                // TODO: check if ordering correct
                std::vector<std::string> clauseAtomAdornments(clause->getAtoms().size());
                std::vector<unsigned int> ordering(clause->getAtoms().size());
                std::set<std::string> boundArgs;

                // mark all bound arguments from head adornment
                AstAtom* clauseHead = clause->getHead();
                std::string headAdornment = currPredicate.getAdornment();
                std::vector<AstArgument*> headArguments = clauseHead->getArguments();

                for (size_t argnum = 0; argnum < headArguments.size(); argnum++) {
                    if (headAdornment[argnum] == 'b') {
                        AstArgument* currArg = headArguments[argnum];
                        std::string name = getString(currArg);
                        boundArgs.insert(name);
                    }
                }

                // mark all bound arguments from the body
                std::vector<AstConstraint*> constraints = clause->getConstraints();

                for (size_t i = 0; i < constraints.size(); i++) {
                    AstConstraint* constraint = constraints[i];
                    BinaryConstraintOp op = constraint->getOperator();
                    // TODO: check if MATCH works (or if this works at all)
                    // if(op != BinaryConstraintOp::EQ && op != BinaryConstraintOp::MATCH){
                    if (op != BinaryConstraintOp::EQ) {
                        continue;
                    }
                    AstArgument* lhs = constraint->getLHS();
                    AstArgument* rhs = constraint->getRHS();

                    if (isBoundArg(lhs, rhs, boundArgs)) {
                        boundArgs.insert(getString(lhs));
                    }
                    if (isBoundArg(rhs, lhs, boundArgs)) {
                        boundArgs.insert(getString(rhs));
                    }
                }

                std::vector<AstAtom*> atoms = clause->getAtoms();
                int atomsAdorned = 0;
                int atomsTotal = atoms.size();

                while (atomsAdorned < atomsTotal) {
                    int firstedb = -1;  // index of first edb atom
                    bool atomAdded = false;

                    for (size_t i = 0; i < atoms.size(); i++) {
                        AstAtom* currAtom = atoms[i];
                        if (currAtom == nullptr) {
                            // already done
                            continue;
                        }

                        AstRelationIdentifier atomName = currAtom->getName();

                        // check if this is the first edb atom met
                        if (firstedb < 0 && contains(adornmentEdb, atomName)) {
                            firstedb = i;
                        }

                        if (hasBoundArgument(currAtom, boundArgs)) {
                            // bound argument found, so based on this SIPS, we adorn it
                            atomAdded = true;

                            // find the adornment pattern
                            // TODO: check if inserting into a set in another function affects the local one
                            std::pair<std::string, std::set<std::string>> result =
                                    bindArguments(currAtom, boundArgs);
                            std::string atomAdornment = result.first;
                            boundArgs = result.second;

                            AstRelationIdentifier atomName = currAtom->getName();

                            // check if we've already dealt with this adornment before
                            if (!contains(seenPredicates, atomName, atomAdornment)) {
                                currentPredicates.push_back(AdornedPredicate(atomName, atomAdornment));
                                seenPredicates.insert(AdornedPredicate(atomName, atomAdornment));
                            }

                            clauseAtomAdornments[i] = atomAdornment;
                            ordering[i] = atomsAdorned;

                            atoms[i] = nullptr;
                            atomsAdorned++;
                            break;
                        }
                    }

                    if (!atomAdded) {
                        size_t i = 0;
                        if (firstedb >= 0) {
                            i = firstedb;
                        } else {
                            for (i = 0; i < atoms.size(); i++) {
                                if (atoms[i] != nullptr) {
                                    break;
                                }
                            }
                        }

                        // TODO: get rid of repetitive code
                        AstAtom* currAtom = atoms[i];
                        AstRelationIdentifier atomName = currAtom->getName();

                        // TODO: check if adding in another function is the same as adding to local
                        std::pair<std::string, std::set<std::string>> result =
                                bindArguments(currAtom, boundArgs);
                        std::string atomAdornment = result.first;
                        std::set<std::string> boundArgs = result.second;

                        if (!contains(seenPredicates, atomName, atomAdornment)) {
                            currentPredicates.push_back(AdornedPredicate(atomName, atomAdornment));
                            seenPredicates.insert(AdornedPredicate(atomName, atomAdornment));
                        }

                        clauseAtomAdornments[i] = atomAdornment;
                        ordering[i] = atomsAdorned;

                        atoms[i] = nullptr;
                        atomsAdorned++;
                    }
                }
                adornedClauses.push_back(
                        AdornedClause(clause, headAdornment, clauseAtomAdornments, ordering));
            }
        }
        adornmentClauses.push_back(adornedClauses);
    }

    ignoredAtoms = addIgnoredRelations(program, ignoredAtoms);
    ignoredAtoms = addDependencies(program, ignoredAtoms);
}

void Adornment::outputAdornment(std::ostream& os) {
    for (size_t i = 0; i < adornmentClauses.size(); i++) {
        std::vector<AdornedClause> clauses = adornmentClauses[i];
        os << "Output " << i + 1 << ": " << adornmentRelations[i] << std::endl;
        for (AdornedClause clause : clauses) {
            os << clause << std::endl;
        }
        os << std::endl;
    }
}

/* =======================  *
 * Magic Set Transformation *
 * =======================  */

void separateDBs(AstProgram* program) {
    for (AstRelation* relation : program->getRelations()) {
        AstRelationIdentifier relName = relation->getName();

        bool is_edb = false;
        bool is_idb = false;

        for (AstClause* clause : relation->getClauses()) {
            if (clause->isFact()) {
                is_edb = true;
            } else {
                is_idb = true;
            }
            if (is_edb && is_idb) {
                break;
            }
        }

        if (is_edb && is_idb) {
            std::string newEdbName = getNextEdbName(program);
            AstRelation* newEdbRel = createNewRelation(relation, newEdbName);
            program->appendRelation(std::unique_ptr<AstRelation>(newEdbRel));

            for (AstClause* clause : relation->getClauses()) {
                if (clause->isFact()) {
                    AstClause* newEdbClause = clause->clone();  // TODO: check if should setSrcLoc
                    // TODO: check if should delete old one
                    newEdbClause->getHead()->setName(newEdbName);
                    program->appendClause(std::unique_ptr<AstClause>(newEdbClause));
                }
            }

            AstClause* newIdbClause = new AstClause();
            newIdbClause->setSrcLoc(nextSrcLoc(relation->getSrcLoc()));

            // oldname(arg1...argn) :- newname(arg1...argn)
            AstAtom* headAtom = new AstAtom(relName);
            AstAtom* bodyAtom = new AstAtom(newEdbName);

            size_t numargs = relation->getArity();
            for (size_t j = 0; j < numargs; j++) {
                std::stringstream argName;
                argName.str("");
                argName << "arg" << j;
                headAtom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
                bodyAtom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
            }

            newIdbClause->setHead(std::unique_ptr<AstAtom>(headAtom));
            newIdbClause->addToBody(std::unique_ptr<AstAtom>(bodyAtom));

            program->appendClause(std::unique_ptr<AstClause>(newIdbClause));
        }
    }
}

void replaceUnderscores(AstProgram* program) {
    for (AstRelation* rel : program->getRelations()) {
        std::vector<AstClause*> clauses = rel->getClauses();
        for (size_t clauseNum = 0; clauseNum < clauses.size(); clauseNum++) {
            AstClause* clause = clauses[clauseNum];
            AstClause* newClause = clause->cloneHead();

            for (AstLiteral* lit : clause->getBodyLiterals()) {
                if (dynamic_cast<AstAtom*>(lit) == 0) {
                    newClause->addToBody(std::unique_ptr<AstLiteral>(lit->clone()));
                    continue;
                }

                AstAtom* newLit = lit->getAtom()->clone();
                std::vector<AstArgument*> args = newLit->getArguments();
                for (size_t argNum = 0; argNum < args.size(); argNum++) {
                    AstArgument* currArg = args[argNum];

                    if (dynamic_cast<const AstVariable*>(currArg)) {
                        AstVariable* var = (AstVariable*)currArg;
                        if (hasPrefix(var->getName(), "+underscore")) {
                            newLit->setArgument(
                                    argNum, std::unique_ptr<AstArgument>(new AstUnnamedVariable()));
                        }
                    }
                }
                newClause->addToBody(std::unique_ptr<AstLiteral>(newLit));
            }
            rel->removeClause(clause);
            rel->addClause(std::unique_ptr<AstClause>(newClause));
        }
    }
}

bool MagicSetTransformer::transform(AstTranslationUnit& translationUnit) {
    // STEPS:
    // For all output relations G:
    // -- Get the adornment S for this clause
    // -- Add to S the set of magic rules for all clauses in S
    // -- For all clauses H :- T in S:
    // -- -- Replace the clause with H :- mag(H), T.
    // -- Add the fact m_G_f...f to S
    // Remove all old idb rules

    AstProgram* program = translationUnit.getProgram();

    separateDBs(program);  // make EDB int IDB = empty

    Adornment* adornment = translationUnit.getAnalysis<Adornment>();  // perform adornment

    // edb/idb handling
    std::vector<std::vector<AdornedClause>> allAdornedClauses = adornment->getAdornedClauses();
    std::set<AstRelationIdentifier> negatedAtoms = adornment->getNegatedAtoms();
    std::set<AstRelationIdentifier> ignoredAtoms = adornment->getIgnoredAtoms();
    std::set<AstRelationIdentifier> oldIdb = adornment->getIDB();
    std::set<AstRelationIdentifier> newIdb;

    // additions
    std::vector<AstRelationIdentifier> newQueryNames;
    std::vector<AstClause*> newClauses;

    // output handling
    std::vector<AstRelationIdentifier> outputQueries = adornment->getRelations();
    std::set<AstRelationIdentifier> addAsOutput;
    std::set<AstRelationIdentifier> addAsPrintSize;
    std::map<AstRelationIdentifier, std::vector<AstIODirective*>> outputDirectives;

    // perform magic set algorithm for each output
    for (size_t querynum = 0; querynum < outputQueries.size(); querynum++) {
        AstRelationIdentifier outputQuery = outputQueries[querynum];
        std::vector<AdornedClause> adornedClauses = allAdornedClauses[querynum];

        // add a relation for the output query
        AstRelation* outputRelationFree = new AstRelation();

        size_t num_free = program->getRelation(outputQuery)->getArity();
        std::string frepeat = std::string(num_free, 'f');

        // mN_outputname_ff...f()
        AstRelationIdentifier magicOutputName =
                createMagicIdentifier(createAdornedIdentifier(outputQuery, frepeat), querynum);
        outputRelationFree->setName(magicOutputName);
        newQueryNames.push_back(magicOutputName);

        program->appendRelation(std::unique_ptr<AstRelation>(outputRelationFree));
        AstClause* finalOutputClause = new AstClause();
        finalOutputClause->setSrcLoc(nextSrcLoc(program->getRelation(outputQuery)->getSrcLoc()));
        finalOutputClause->setHead(std::unique_ptr<AstAtom>(new AstAtom(magicOutputName)));
        program->appendClause(std::unique_ptr<AstClause>(finalOutputClause));

        for (AdornedClause adornedClause : adornedClauses) {
            AstClause* clause = adornedClause.getClause();
            AstRelationIdentifier originalName = clause->getHead()->getName();

            if (contains(ignoredAtoms, originalName)) {
                continue;
            }

            std::string headAdornment = adornedClause.getHeadAdornment();
            AstRelationIdentifier newRelName = createAdornedIdentifier(originalName, headAdornment);
            AstRelation* adornedRelation = program->getRelation(newRelName);

            if (adornedRelation == nullptr) {
                // create the relation with the new adornment
                AstRelation* originalRelation = program->getRelation(originalName);

                AstRelation* newRelation = createNewRelation(originalRelation, newRelName);

                // TODO: CHECK IF NEEDED ELSEWHERE (espec for output relations)
                // TODO: fix the setup v messy
                // TODO: remove inputDirectives from the following code
                // TODO: why didn't I just use the getIODirectives thing what the heck
                // -- to change the input file if needed bc of defaults
                if (originalRelation->isInput()) {
                    IODirectives inputDirectives;
                    AstIODirective* newDirective = new AstIODirective();
                    inputDirectives.setRelationName(newRelName.getNames()[0]);  // TODO: CHECK IF FIRSTN AME
                    newDirective->addName(newRelName);
                    newDirective->setAsInput();
                    for (AstIODirective* current : originalRelation->getIODirectives()) {
                        if (current->isInput()) {
                            for (const auto& currentPair : current->getIODirectiveMap()) {
                                newDirective->addKVP(currentPair.first, currentPair.second);
                                inputDirectives.set(currentPair.first, currentPair.second);
                            }
                        }
                    }
                    if (!inputDirectives.has("IO")) {
                        inputDirectives.setIOType("file");
                        newDirective->addKVP("IO", "file");
                    }
                    if (inputDirectives.getIOType() == "file" && !inputDirectives.has("filename")) {
                        newDirective->addKVP("filename",
                                originalName.getNames()[0] + ".facts");  // TODO: CHECK IF FIRSTN AME
                    }

                    newRelation->addIODirectives(std::unique_ptr<AstIODirective>(newDirective));
                }

                program->appendRelation(std::unique_ptr<AstRelation>(newRelation));
                adornedRelation = newRelation;
            }

            AstClause* newClause = clause->clone();
            newClause->getHead()->setName(newRelName);
            newClause->reorderAtoms(reorderOrdering(adornedClause.getOrdering()));

            // add adornments to names
            std::vector<AstLiteral*> body = newClause->getBodyLiterals();
            std::vector<std::string> bodyAdornment = adornedClause.getBodyAdornment();

            std::vector<unsigned int> adordering = adornedClause.getOrdering();

            bodyAdornment = reorderAdornment(bodyAdornment, adordering);

            int count = 0;

            // set the name of each IDB pred in the clause to be the adorned version
            for (size_t i = 0; i < body.size(); i++) {
                AstLiteral* lit = body[i];

                // only IDB should be added
                if (dynamic_cast<AstAtom*>(lit)) {
                    AstRelationIdentifier litName = lit->getAtom()->getName();
                    if (contains(oldIdb, litName)) {
                        // only do this to the IDB
                        if (!contains(ignoredAtoms, litName)) {
                            AstRelationIdentifier newLitName =
                                    createAdornedIdentifier(litName, bodyAdornment[count]);
                            AstAtom* atomlit = dynamic_cast<AstAtom*>(lit);
                            atomlit->setName(newLitName);
                            newIdb.insert(newLitName);
                        } else {
                            newIdb.insert(litName);
                        }
                    }
                    count++;  // TODO: check if placement of this line is correct
                }
            }

            // Add the set of magic rules
            for (size_t i = 0; i < body.size(); i++) {
                AstLiteral* currentLiteral = body[i];
                count = 0;
                if (dynamic_cast<AstAtom*>(currentLiteral)) {
                    AstAtom* lit = (AstAtom*)currentLiteral;
                    AstRelationIdentifier litName = lit->getAtom()->getName();
                    if (contains(newIdb, litName) && !contains(ignoredAtoms, litName)) {
                        // AstClause* magicClause = newClause->clone();
                        AstRelationIdentifier newLitName = createMagicIdentifier(litName, querynum);
                        if (program->getRelation(newLitName) == nullptr) {
                            AstRelation* magicRelation = new AstRelation();
                            magicRelation->setName(newLitName);

                            std::string mainLitName = litName.getNames()[0];
                            int endpt = getEndpoint(mainLitName);

                            AstRelationIdentifier originalRelationName =
                                    createSubIdentifier(litName, 0, endpt);
                            AstRelation* originalRelation = program->getRelation(originalRelationName);

                            std::string currAdornment = bodyAdornment[i];
                            int argcount = 0;

                            for (AstAttribute* attr : originalRelation->getAttributes()) {
                                if (currAdornment[argcount] == 'b') {
                                    magicRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
                                }
                                argcount++;
                            }
                            program->appendRelation(std::unique_ptr<AstRelation>(magicRelation));
                        }

                        AstAtom* magicHead = new AstAtom(newLitName);
                        std::string currAdornment = bodyAdornment[i];
                        int argCount = 0;

                        for (AstArgument* arg : lit->getArguments()) {
                            if (currAdornment[argCount] == 'b') {
                                magicHead->addArgument(std::unique_ptr<AstArgument>(arg->clone()));
                            }
                            argCount++;
                        }

                        AstClause* magicClause = new AstClause();
                        magicClause->setSrcLoc(nextSrcLoc(lit->getSrcLoc()));
                        magicClause->setHead(std::unique_ptr<AstAtom>(magicHead));

                        // make the body
                        AstRelationIdentifier magPredName =
                                createMagicIdentifier(newClause->getHead()->getName(), querynum);
                        std::string mainLitName = magPredName.getNames()[0];

                        int endpt = getEndpoint(mainLitName);

                        std::string curradorn =
                                mainLitName.substr(endpt + 1, mainLitName.size() - (endpt + 1));

                        if (program->getRelation(magPredName) == nullptr) {
                            AstRelation* freeRelation = new AstRelation();
                            freeRelation->setName(magPredName);
                            AstRelation* currrel = program->getRelation(newClause->getHead()->getName());
                            std::vector<AstAttribute*> attrs = currrel->getAttributes();
                            for (size_t currarg = 0; currarg < currrel->getArity(); currarg++) {
                                if (curradorn[currarg] == 'b') {
                                    freeRelation->addAttribute(
                                            std::unique_ptr<AstAttribute>(attrs[currarg]->clone()));
                                }
                            }
                            program->appendRelation(std::unique_ptr<AstRelation>(freeRelation));
                        }
                        AstAtom* addedMagPred = new AstAtom(magPredName);
                        argCount = 0;
                        for (AstArgument* arg : newClause->getHead()->getArguments()) {
                            if (headAdornment[argCount] == 'b') {
                                addedMagPred->addArgument(std::unique_ptr<AstArgument>(arg->clone()));
                            }
                            argCount++;
                        }

                        magicClause->addToBody(std::unique_ptr<AstAtom>(addedMagPred));
                        for (size_t j = 0; j < i; j++) {
                            magicClause->addToBody(std::unique_ptr<AstLiteral>(body[j]->clone()));
                        }

                        // go through the arguments in the head and bind the bound variables
                        std::vector<AstArgument*> currArguments = magicClause->getHead()->getArguments();
                        for (size_t i = 0; i < currArguments.size(); i++) {
                            AstArgument* arg = currArguments[i];
                            std::string argName = getString(arg);

                            // all bound arguments begin with "+abdul" (see AstTrans)
                            if (hasPrefix(argName, "+abdul")) {
                                // check if string or num constant
                                size_t argStart = argName.find('_');
                                std::string res = argName.substr(argStart + 1, argName.size());

                                AstArgument* newArgument;
                                if (res[res.size() - 1] == 's') {
                                    // string argument
                                    const char* str = res.substr(0, res.size() - 2).c_str();
                                    newArgument =
                                            new AstStringConstant(translationUnit.getSymbolTable(), str);
                                } else {
                                    // numeric argument
                                    size_t argEnd = argName.find('_', argStart + 1);
                                    std::string startstr =
                                            argName.substr(argStart + 1, argEnd - argStart - 1);
                                    newArgument = new AstNumberConstant(stoi(startstr));
                                }

                                // add the constraint to the body of the clause
                                AstConstraint* newConstraint = new AstConstraint(BinaryConstraintOp::EQ,
                                        std::unique_ptr<AstArgument>(arg->clone()),
                                        std::unique_ptr<AstArgument>(newArgument));
                                magicClause->addToBody(std::unique_ptr<AstLiteral>(newConstraint));
                            }
                        }
                        program->appendClause(std::unique_ptr<AstClause>(magicClause));
                    }
                }
            }

            // replace with H :- mag(H), T
            size_t numAtoms = newClause->getAtoms().size();
            const AstAtom* newClauseHead = newClause->getHead()->getAtom();
            AstRelationIdentifier newMag = createMagicIdentifier(newClauseHead->getName(), querynum);
            AstAtom* newMagAtom = new AstAtom(newMag);
            std::vector<AstArgument*> args = newClauseHead->getArguments();

            for (size_t k = 0; k < args.size(); k++) {
                if (headAdornment[k] == 'b') {
                    newMagAtom->addArgument(std::unique_ptr<AstArgument>(args[k]->clone()));
                }
            }

            newClause->addToBody(std::unique_ptr<AstAtom>(newMagAtom));
            std::vector<unsigned int> newClauseOrder(numAtoms + 1);

            for (size_t k = 0; k < numAtoms; k++) {
                newClauseOrder[k] = k + 1;
            }
            newClauseOrder[numAtoms] = 0;
            newClause->reorderAtoms(reorderOrdering(newClauseOrder));

            newClause->setSrcLoc(nextSrcLoc(newClause->getSrcLoc()));

            // add the clause
            newClauses.push_back(newClause);
            adornedRelation->addClause(std::unique_ptr<AstClause>(newClause));
        }
    }

    // remove all old IDB relations
    for (AstRelationIdentifier relationName : oldIdb) {
        AstRelation* relation = program->getRelation(relationName);
        if (relation->isOutput()) {
            addAsOutput.insert(relationName);
            std::vector<AstIODirective*> clonedDirectives;
            for (AstIODirective* iodir : relation->getIODirectives()) {
                clonedDirectives.push_back(iodir->clone());
            }
            outputDirectives[relationName] = clonedDirectives;
        } else if (relation->isPrintSize()) {
            addAsPrintSize.insert(relationName);
            std::vector<AstIODirective*> clonedDirectives;
            for (AstIODirective* iodir : relation->getIODirectives()) {
                clonedDirectives.push_back(iodir->clone());
            }
            outputDirectives[relationName] = clonedDirectives;
        }
        if (!(contains(ignoredAtoms, relationName) || contains(negatedAtoms, relationName) ||
                    isAggRel(relationName))) {
            program->removeRelation(relationName);
        }
    }

    // add output relations
    for (size_t i = 0; i < outputQueries.size(); i++) {
        AstRelationIdentifier oldName = outputQueries[i];
        AstRelationIdentifier newName = newQueryNames[i];

        std::string firstName = newName.getNames()[0];
        size_t prefixpoint = firstName.find("_");

        AstRelationIdentifier newRelationName =
                createSubIdentifier(newName, prefixpoint + 1, firstName.size() - (prefixpoint + 1));
        AstRelation* adornedRelation = program->getRelation(newRelationName);
        if (adornedRelation == nullptr) {
            continue;  // TODO: WHY IS THIS HERE?
        }

        size_t numargs = adornedRelation->getArity();

        AstRelation* outputRelation;
        if (program->getRelation(oldName) != nullptr) {
            outputRelation = program->getRelation(oldName);
        } else {
            outputRelation = new AstRelation();
            outputRelation->setSrcLoc(nextSrcLoc(adornedRelation->getSrcLoc()));

            for (AstAttribute* attr : adornedRelation->getAttributes()) {
                outputRelation->addAttribute(std::unique_ptr<AstAttribute>(attr->clone()));
            }

            outputRelation->setName(oldName);

            // set as output relation - TODO: check if needed with the new model!
            AstIODirective* newdir = new AstIODirective();

            if (addAsOutput.find(oldName) != addAsOutput.end()) {
                newdir->setAsOutput();
            } else {
                newdir->setAsPrintSize();
            }

            outputRelation->addIODirectives(std::unique_ptr<AstIODirective>(newdir));

            program->appendRelation(std::unique_ptr<AstRelation>(outputRelation));
        }

        // oldname(arg1...argn) :- newname(arg1...argn)
        AstAtom* headatom = new AstAtom(oldName);
        AstAtom* bodyatom = new AstAtom(newRelationName);

        for (size_t j = 0; j < numargs; j++) {
            std::stringstream argName;
            argName.str("");
            argName << "arg" << j;
            headatom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
            bodyatom->addArgument(std::unique_ptr<AstArgument>(new AstVariable(argName.str())));
        }

        AstClause* referringClause = new AstClause();
        referringClause->setSrcLoc(nextSrcLoc(outputRelation->getSrcLoc()));
        referringClause->setHead(std::unique_ptr<AstAtom>(headatom));
        referringClause->addToBody(std::unique_ptr<AstAtom>(bodyatom));

        program->appendClause(std::unique_ptr<AstClause>(referringClause));
    }

    for (std::pair<AstRelationIdentifier, std::vector<AstIODirective*>> iopair : outputDirectives) {
        for (AstIODirective* iodir : iopair.second) {
            program->getRelation(iopair.first)->addIODirectives(std::unique_ptr<AstIODirective>(iodir));
        }
    }

    replaceUnderscores(program);

    return true;
}
}  // end of namespace souffle
